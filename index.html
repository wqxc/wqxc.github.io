<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>wqxc&#39;s code world</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="wqxc&#39;s code world">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wqxc&#39;s code world">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="WQXC">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="wqxc&#39;s code world" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">wqxc&#39;s code world</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-浏览器/输入URL之后" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E/" class="article-date">
  <time datetime="2021-05-21T09:16:56.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/">浏览器原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E/">输入URL之后</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="输入URL之后发生了什么事情"><a href="#输入URL之后发生了什么事情" class="headerlink" title="输入URL之后发生了什么事情"></a>输入URL之后发生了什么事情</h2><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210416171643925.png" alt="image-20210416171643925"></p>
<p>如上所示是在浏览器中输入一个URl后所经过的操作。</p>
<p>整个过程需要不同的进程相互配合。</p>
<h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h4><p>用户输入的内容总的来说有两种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">一个url地址</span><br><span class="line">httt:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">baidu.com</span><br><span class="line">taobao.com</span><br><span class="line"></span><br><span class="line">一个搜索关键字</span><br><span class="line">人为啥活着</span><br><span class="line">百度</span><br><span class="line">谷歌</span><br></pre></td></tr></table></figure>

<p>浏览器会判断用户输入的是一个url还是关键字。主要是判断输入的内容是否符合 URL规则</p>
<p>如果是一个搜索关键词，浏览器会将其整理一下，使用默认的搜索引擎合成带有搜索字样的url然后发起网络请求。</p>
<p>用户按下回车键之后，tab标签会开始旋转的loading。这个时候，页面依旧还是停留在原来的页面上的。需要到提交文档阶段，页面内容才会被替换。</p>
<h4 id="网络进程"><a href="#网络进程" class="headerlink" title="网络进程"></a>网络进程</h4><p>一个url核心是获取一个网络资源，这就需要用到网络进程，这就需要浏览器进程将url请求发送到网络进程，让网络进程来下载资源。这里chrome是依靠进程间通道（IPC）来实现不同进程之间的通信的。</p>
<p><strong>URL请求流程</strong></p>
<p>先查找缓存，看看有木有缓存资源，有的话就返回缓存资源，没有缓存就进入网络请求流程</p>
<p>接着是DNS解析，解析域名所对应的IP地址，然后利用IP地址和服务器建立TCP链接</p>
<p>链接建立之后，浏览器构造请求行，请求头等信息，然后将和该域名相关的cookie加入到附加请求头中，</p>
<p>然后发送请求信息</p>
<p>服务器接受到信息之后，生成响应数据返回给网络进程，网络进程解析响应信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">***网络进程的解析***</span><br><span class="line"></span><br><span class="line">主要是根据状态码进行解析，</span><br><span class="line"></span><br><span class="line">如果是<span class="number">301</span>、<span class="number">302</span>，那么响应头中必然存在Location字段，是用来重定向的。</span><br><span class="line"></span><br><span class="line">响应的数据类型</span><br><span class="line"></span><br><span class="line">Content-Type 告诉浏览器返回的数据是什么类型的。</span><br><span class="line">text/html 表示返回的是一个html文件</span><br><span class="line">application/octet-stream 表示是一个字节流，一般浏览器会按照下载类型来处理，将这个请求内容下载下来</span><br></pre></td></tr></table></figure>

<p>网络进程之后，拿到了html文件，浏览器就需要准备渲染进程</p>
<p>接下来是提交文档阶段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">这里的文档是URL请求的响应体数据</span><br><span class="line">提交文档的消息是由浏览器进程发出的</span><br><span class="line">浏览器进程发出了提交文档的消息，渲染进程接受这个消息后就知道文档准备好了，可以接收了。</span><br><span class="line">渲染进程和网络进程建立数据的传输通道，也就是IPC</span><br><span class="line">数据传输完毕之后，渲染进程发送消息 &#39;确认提交&#39; 给浏览器进程，表示数据接收完毕了。</span><br><span class="line">收到 &#39;确认提交&#39;的消息之后，浏览器进程处理url输入框，更新前进后退按钮的状态，以及安全锁的状态，并更新web页面</span><br><span class="line">这个时候，页面开始从老页面转向新的页面。</span><br><span class="line">	这也是为什么，输入url之后，我们依旧停留在原有的页面上，过了一会儿，页面才会更新。</span><br><span class="line"> </span><br><span class="line">到此，一个导航流程结束了，接下来就进入到渲染阶段了。</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E/" data-id="ckoy7a4cy002iipoabk7p91yk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器/创建DOM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%88%9B%E5%BB%BADOM/" class="article-date">
  <time datetime="2021-05-21T09:05:16.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/">浏览器原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%88%9B%E5%BB%BADOM/">HTML转换为DOM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关于DOM"><a href="#关于DOM" class="headerlink" title="关于DOM"></a>关于DOM</h2><h4 id="HTML解析为DOM"><a href="#HTML解析为DOM" class="headerlink" title="HTML解析为DOM"></a>HTML解析为DOM</h4><p>首先，前端写的是一个html文件。</p>
<p>这些html本身是没有意义的，有意义的是DOM，html转换为DOM的步骤如下所示：</p>
<p>1、html文件通过网络进程被下载之后，传输给渲染进程。</p>
<p>2、渲染进程中又一个HTML解析器，这个解析器的职责就是负责将HTML转换为DOM。</p>
<p>3、渲染进程的核心线程会调用HTML解析器将HTML文件转换为DOM。</p>
<p>4、HTMl文件是一边下载，HTML解析器一边解析，网络进程和渲染进程之间会建立一个共享数据的管道，html文    件一边下载，一边被html解析器解析</p>
<p>5、HTMl解析器的原理，首先也是叫做分词</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;    </span><br><span class="line">  	&lt;div&gt;<span class="number">1</span>&lt;<span class="regexp">/div&gt;    </span></span><br><span class="line"><span class="regexp">		&lt;div&gt;test&lt;/</span>div&gt;</span><br><span class="line">	&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>以上分词的结果如下：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210427140028237.png" alt="image-20210427140028237"></p>
<p>然后一个个的词被放进栈中，如果放进去的是 StartTag Token ,HTML解析器会为该Token创建一个DOM节点。然后将该节点放入DOM树中，它的父节点就是栈中相邻的那个元素生成的节点。</p>
<p>初始状态下，HTML解析器会默认创建一个根DOM节点 Document节点。</p>
<p>然后，以上边的例子来说：</p>
<p>StartTag HTML 放在栈中，而后创建一个HTML DOM节点，并挂载在Document下。</p>
<p>像是这样：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210427140536026.png" alt="image-20210427140536026"></p>
<p>然后呢，创建 body div，状态如下所示：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210427140645972.png" alt="image-20210427140645972"></p>
<p>接下来，到了文本 1，HTML解析器发现，这个不是一个HTMl标签，而是一个文本，这个时候HTML解析器会创建一个文本节点，而后将其挂载到上一个DOM节点上。如下所示：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210427140948673.png" alt="image-20210427140948673"></p>
<p>再往后，遇到了EndTag div ,HTML解析器回去判断当前栈顶的元素是不是 StartTag div 如果是，那么就说明这一对标签创建完成了。就将StartTag div 弹出。</p>
<p>依次往下，整个DOM树就构建完成了。</p>
<h4 id="JS影响DOM"><a href="#JS影响DOM" class="headerlink" title="JS影响DOM"></a>JS影响DOM</h4><p>结论：js影响DOM的解析</p>
<p>HTML解析器在解析HTML的时候，遇到了 <strong>script</strong> ，HTML解析器就会停下HTML解析</p>
<p>script  有两种形式</p>
<p>其一是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;    </span><br><span class="line">  <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>]    </span><br><span class="line">	div1.innerText = <span class="string">'time.geekbang'</span>    </span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>其二是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"a.js"</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>区别是，第二种情况会调用网络进程，进行下载。</p>
<p>JS可以操作DOM，如果不管js而直接解析DOM，解析完了，js再操作一番DOM，那之前的解析就白费了，所以这里遇到js的时候回停止HTML的解析，等待js下载，而后执行，完毕了之后继续解析HTML。</p>
<p>一般现代的浏览器会在渲染进程中，开启一个预解析线程，预解析线程会扫描HTML文件中包含的JavaScript、CSS等相关文件，预先下载这些文件。</p>
<p>所以说：js会阻塞HTML的解析</p>
<p>解决策略：</p>
<p>是使用deffer  和 async来标记script代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> type=<span class="string">"text/javascript"</span> src=<span class="string">'foo.js'</span>&gt;&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script defer type="text/</span>javascript<span class="string">" src='foo.js'&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>Async :表示js文件下载完成之后理立即行这些代码 可能在 DOMContentLoaded 之前或者之后执行</p>
<p>Deffer：则是表示下载完成之后，在DOMContentLoaded事件之前执行。</p>
<h4 id="JS-CSS"><a href="#JS-CSS" class="headerlink" title="JS CSS"></a>JS CSS</h4><p>js中可能出现以下类似代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div1.style.color=<span class="string">'red'</span></span><br></pre></td></tr></table></figure>

<p>这些代码是用来操作CSSOM的，所以在操作css之前，必须让css都下载下来，所以，如果代码里引用了外部的css文件，那就必须等这些css下载完成，并解析成CSSOM对象之后，才能执行JS脚本。</p>
<p>然后，js引擎在执行js的时候，是不知道这个js文件是不是操作了cssom，所以，js引擎，直接一刀切，不管当前js是否操作了CSSOM,直接等待所有的css都下载了之后，再操作js。</p>
<p>所以说css会阻塞js的执行。</p>
<p>js又会阻塞html的解析。</p>
<p>同理，css会阻塞html的解析</p>
<h4 id="渲染流程1"><a href="#渲染流程1" class="headerlink" title="渲染流程1"></a>渲染流程1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//theme.css </span></span><br><span class="line">div&#123;     <span class="attr">color</span> : coral;    background-color:black&#125;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;    </span><br><span class="line">  	&lt;link href=<span class="string">"theme.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">	&lt;body&gt;    </span></span><br><span class="line"><span class="regexp">    &lt;div&gt;geekbang com&lt;/</span>div&gt;</span><br><span class="line">	&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>



<p>html文件引用了外部的css文件</p>
<p>它的渲染过程如下所示：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210427154946777.png" alt="image-20210427154946777"></p>
<p>首先是发起了网络请求，这个网络请求可能是浏览器主进程发起的，也可以是我们的渲染进程发起的。</p>
<p>而后网络进程接收到返回结果后，提交给渲染进程。这个过程有一个空闲时间，这个空闲时间可能会影响性能。</p>
<p>产生这个空闲的原因有可能是网络延迟。</p>
<p>然后渲染进程解析HTML，前边我们说到，渲染进程会开启一个预解析线程，进行css的下载。</p>
<p>再然后，css下载完成了，使用css解析器解析css文件为CSSOM对象。</p>
<p>然后看一下更复杂的一点情景：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//theme.css</span></span><br><span class="line">div&#123;     </span><br><span class="line">  color : coral;    </span><br><span class="line">  background-color:black</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;    </span><br><span class="line">  	&lt;link href=<span class="string">"theme.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;    </span></span><br><span class="line"><span class="regexp">    &lt;div&gt;geekbang com&lt;/</span>div&gt;    </span><br><span class="line">		&lt;script&gt;        <span class="built_in">console</span>.log(<span class="string">'time.geekbang.org'</span>)    &lt;<span class="regexp">/script&gt;    </span></span><br><span class="line"><span class="regexp">		&lt;div&gt;geekbang com&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>渲染进程如下：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210427160946635.png" alt="image-20210427160946635"></p>
<p>如上，渲染进程的中间，构建DOM的时候，有一段被js阻止。</p>
<p>可以看得出来，CSSOM构建之后，才会执行JavaScript，JavaScript执行完了，就会继续构建DOM。</p>
<p>然后，更复杂的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//theme.css</span></span><br><span class="line">div&#123;     </span><br><span class="line">  color : coral;    </span><br><span class="line">  background-color:black</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//foo.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'time.geekbang.org'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;    </span><br><span class="line">  	&lt;link href=<span class="string">"theme.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line">  &lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;    </span></span><br><span class="line"><span class="regexp">    &lt;div&gt;geekbang com&lt;/</span>div&gt;    </span><br><span class="line">		&lt;script src=<span class="string">'foo.js'</span>&gt;&lt;<span class="regexp">/script&gt;    </span></span><br><span class="line"><span class="regexp">		&lt;div&gt;geekbang com&lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210427161827207.png" alt="image-20210427161827207"></p>
<p>这里的核心是，不管css文件和js文件谁先到达，都要先等到CSS文件下载完成并生成CSSOM之后，js才会开始执行。js执行完毕了之后，才会开始继续渲染。</p>
<p><strong>白屏阶段</strong>：提交数据之后，渲染进程会创建一个空白页面，这个阶段被称之为白屏阶段。这个阶段等待css文件和js文件加载完成，生成CSSOM和DOM，然后合成布局树，而后经过一系列的准备后，就开始首次渲染</p>
<p><strong>提交数据</strong>：就是网络进程下载完毕之后，将下载结果提交给渲染进程，叫做提交数据</p>
<p>白屏时间过长，影响用户体验。</p>
<p>白屏过长的优化手段：</p>
<p>1、通过内联js、内联css，就无需下载，节省时间</p>
<p>2、减少体积</p>
<p>3、async deffer</p>
<p>4、比较大的css可以使用media区分</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%88%9B%E5%BB%BADOM/" data-id="ckoy7a4cv002dipoa053tcn11" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器/浏览器架构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/" class="article-date">
  <time datetime="2021-05-21T08:11:50.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/">浏览器原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/">浏览器架构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>浏览器不是一开始就是多进程的，也不是一开始就那么完善，而是经过进化之后，才是现如今我们看到的那种浏览器。</p>
<h3 id="单进程浏览器"><a href="#单进程浏览器" class="headerlink" title="单进程浏览器"></a>单进程浏览器</h3><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210521114822222.png" alt="image-20210521114822222"></p>
<p>早期的浏览器是单进程，多线程的，这种浏览器 <strong>不稳定</strong> <strong>不流畅</strong> <strong>不安全</strong>。</p>
<p>如果一个线程崩溃了，那么整个浏览器就都挂掉了。</p>
<p>比如打开了一个百度页面，又打开了一个淘宝页面，淘宝页面出现问题了，百度页面也会挂掉，这明显是不靠谱的。</p>
<h3 id="早期多进程浏览器"><a href="#早期多进程浏览器" class="headerlink" title="早期多进程浏览器"></a>早期多进程浏览器</h3><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210521120751841.png" alt="image-20210521120751841"></p>
<p>如上所示，</p>
<p>因为进程是相互隔离的，当一个页面或者插件进程崩溃的时候，仅仅是影响当前进程，会导致整个浏览器崩溃。</p>
<p>这时候，浏览器主进程做了很多的事情，包括下载资源管理IPC，显示渲染进程生成的图片，主进程做的事情太多了，有点多余，所以新的架构又进行了演变。</p>
<h3 id="最新的浏览器"><a href="#最新的浏览器" class="headerlink" title="最新的浏览器"></a>最新的浏览器</h3><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210521140829535.png" alt="image-20210521140829535"></p>
<p>如上，网络进程独被独立了出来，这些进程是打开一个页面所需要的进程。</p>
<h5 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h5><p>负责界面显示，用户交互，子进程管理等，比如浏览器的前进后退操作等。</p>
<h5 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h5><p>主要就是将HTML，CSS，JS 转换为用户可以交互的网页。</p>
<h5 id="GPU进程"><a href="#GPU进程" class="headerlink" title="GPU进程"></a>GPU进程</h5><p>一开始GPU 是用来实现3D CSS的效果，只是后来Chrome 的 UI界面都采用GPU来绘制，所以，新型的浏览器都引入了GPU进程。</p>
<h5 id="网络进程"><a href="#网络进程" class="headerlink" title="网络进程"></a>网络进程</h5><p>负责页面的网络资源的加载。</p>
<h5 id="插件进程"><a href="#插件进程" class="headerlink" title="插件进程"></a>插件进程</h5><p>运行一些插件，插件容易崩溃，所以需要插件进程来隔离。</p>
<h3 id="浏览器中输入内容，到出现页面做了什么？"><a href="#浏览器中输入内容，到出现页面做了什么？" class="headerlink" title="浏览器中输入内容，到出现页面做了什么？"></a>浏览器中输入内容，到出现页面做了什么？</h3><p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210521142910105.png" alt="image-20210521142910105"></p>
<p>整页面打开的过程需要多个进程之间的配合。</p>
<h5 id="第一：用户的输入"><a href="#第一：用户的输入" class="headerlink" title="第一：用户的输入"></a>第一：用户的输入</h5><p>用户输入内容可以是一个关键字或者是一个地址，一个域名。</p>
<h5 id="第二：处理输入信息"><a href="#第二：处理输入信息" class="headerlink" title="第二：处理输入信息"></a>第二：处理输入信息</h5><p>判断一下是导航一个地址还是使用搜索引擎来处理。</p>
<p>两者都是形成一个URL</p>
<h5 id="第三：开始导航"><a href="#第三：开始导航" class="headerlink" title="第三：开始导航"></a>第三：开始导航</h5><p>导航就是发出URL请求到页面开始解析的这个过程叫做导航。</p>
<h5 id="第四：网络请求"><a href="#第四：网络请求" class="headerlink" title="第四：网络请求"></a>第四：网络请求</h5><p>浏览器进程发URL给网络进程，开始下载资源，读取到响应头信息，根据type的不同做不同的操作，比如：</p>
<p>type是 html类型，就会提交浏览器进程来准备渲染进程，如果是下载类型，就提交给下载管理器。</p>
<h5 id="第五：-提交文档"><a href="#第五：-提交文档" class="headerlink" title="第五： 提交文档"></a>第五： 提交文档</h5><p>提交文档的消息是浏览器进程发出的，渲染进程收到 提交文档 的消息后，会和网络进程建立传输数据的 <strong>管道</strong>。</p>
<h5 id="第六：-确认提交文档"><a href="#第六：-确认提交文档" class="headerlink" title="第六： 确认提交文档"></a>第六： 确认提交文档</h5><p>文档数据传输完毕之后，渲染进程会返回确认 <strong>提交</strong> 的消息给浏览器进程。</p>
<p>浏览器接收到消息后会修改界面状态，安全状态，地址栏的URL，前进后退的历史状态。</p>
<h5 id="第七：渲染阶段"><a href="#第七：渲染阶段" class="headerlink" title="第七：渲染阶段"></a>第七：渲染阶段</h5><p>渲染页面</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/" data-id="ckoy7a4cw002eipoabpwbb1p2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器/渲染流水线" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" class="article-date">
  <time datetime="2021-05-21T08:11:12.000Z" itemprop="datePublished">2021-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/">浏览器原理</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/">渲染流水线</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210519171828121.png" alt=""></p>
<h3 id="加载主页面"><a href="#加载主页面" class="headerlink" title="加载主页面"></a>加载主页面</h3><p>加载主页面，调用网络进程，下载HTML文件。</p>
<p>下载完成之后，渲染进程解析HTML，而后构建DOM。</p>
<p>在解析HTML的时候，浏览器会预先下载HTML文件内需要的JS资源和CSS资源。</p>
<p>这里JS会阻塞DOM的解析，必然也会影响渲染吗，</p>
<p>另外的，JS的执行，需要CSSOM构建完毕之后才能执行，</p>
<p>所以CSS会阻塞JS的执行，JS会阻塞DOM的解析，所以，CSS也间接的会阻塞DOM的解析，这里的阻塞不是必然的，是一种可能性。</p>
<p>CSS会阻塞浏览器的渲染。</p>
<p>所以，CSS放在最前边，JS放在最后边。</p>
<h3 id="构建DOM"><a href="#构建DOM" class="headerlink" title="构建DOM"></a>构建DOM</h3><p>HTML文件浏览器是不认识的，需要转换为浏览器能够处理的结构 ———— <strong>DOM</strong></p>
<h3 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h3><p>样式计算是在CSS文件获取完成之后进行的，主要作用是计算出每一个DOM节点中，每一个元素的样式，这个过程分为下图所示的三样：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210519171905175.png" alt="样式计算"></p>
<h5 id="第一，将CSS文件转换为浏览器能识别的形式—styleSheets"><a href="#第一，将CSS文件转换为浏览器能识别的形式—styleSheets" class="headerlink" title="第一，将CSS文件转换为浏览器能识别的形式—styleSheets"></a>第一，将CSS文件转换为浏览器能识别的形式—styleSheets</h5><p>CSS样式来源主要有三种：1、<style> 标签内的CSS。 2、link标签引入的。3、内嵌入HTML标签的CSS</p>
<p>CSS文件，和HTML文件一样，浏览器本身是理解不了的，需要将其转换为浏览器可以理解的结构—styleSheets。 styleSheets 也叫做 CSSOM</p>
<h5 id="第二，转换样式表中的属性值，使其标准化"><a href="#第二，转换样式表中的属性值，使其标准化" class="headerlink" title="第二，转换样式表中的属性值，使其标准化"></a>第二，转换样式表中的属性值，使其标准化</h5><p>比如，CSS中又很多 2rem,blue,bold 值。</p>
<p>就需要将其标准化为一个值，比如 2rem 就是  32px，blue 被解析为rgb, bold被解析为700.</p>
<h5 id="第三，计算出DOM树中每个节点的具体样式"><a href="#第三，计算出DOM树中每个节点的具体样式" class="headerlink" title="第三，计算出DOM树中每个节点的具体样式"></a>第三，计算出DOM树中每个节点的具体样式</h5><p>这里涉及CSS的继承规则和层叠规则。</p>
<p>首先是CSS继承，CSS继承就是每个DOM节点都包含有父节点的样式。比如，html设定了font-size:20px.</p>
<p>其他的文本，没有设定 font-size 就会默认继承 html的字体。</p>
<p>层叠规则主要是根据CSS权重来处理。</p>
<p>样式计算阶段的目的是为了计算出DOM节点中，每个元素的具体样式，根据CSS的继承和层叠两个规则。</p>
<h3 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h3><p>到了现在，我们有了DOM树和CSSOM树，有了元素，有了样式，唯一缺少的是DOM元素的几何信息，接下来要做的就是计算出DOM树中 <strong>可见元素</strong> 的位置信息。</p>
<p>布局阶段，主要完成两件是 <strong>创建布局树</strong> 和 <strong>布局计算</strong></p>
<h5 id="创建布局树"><a href="#创建布局树" class="headerlink" title="创建布局树"></a>创建布局树</h5><p>DOM树种包含了很多不可见的元素，比如head标签，display：none 属性的元素，所以还要额外的构建一棵可见元素的布局树。</p>
<p>核心是遍历DOM树，可见的就放在布局树上，不可见的就放弃。</p>
<h5 id="布局计算"><a href="#布局计算" class="headerlink" title="布局计算"></a>布局计算</h5><p>计算布局树的坐标位置，这个过程很复杂。</p>
<p>计算完成之后，每一个元素的几何坐标信息就存储在布局树中。</p>
<p>这时候，布局树就包含了布局的多数信息。</p>
<h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>布局阶段，计算了元素的位置信息，按道理来说，有了元素，有了元素的位置信息，已经可以绘制页面了，但是，直接进行绘制的话，会有很大的性能问题，这里，浏览器做了另外的操作  ————  <strong>分层</strong></p>
<p>为什么要分层？</p>
<p>页面上会有很多的效果，比如 3D变换，页面的滚动，横向的元素运动等。</p>
<p>如果所有的元素，在一个层面内，元素的变化必然引整个页面的重新布局计算。</p>
<p>而分层就可以解决这个问题，将这些变换的元素单独的分为一层，一些特殊的效果在这些层上去做，将影响降为最小。</p>
<p>最终，将多个分层合并在一起，最终合成一个页面，展示出来。</p>
<p>分层阶段，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的———— <strong>图层树</strong></p>
<h5 id="如何成为一层"><a href="#如何成为一层" class="headerlink" title="如何成为一层"></a>如何成为一层</h5><p>第一：拥有层叠上下文属性的元素会被单独提升为一层</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">position: absolute|releative  并且 z-index值不为auto</span><br><span class="line">flex 容器的子元素  z-index 不为auto</span><br><span class="line">grid 容器的子元素，z-index不为auto</span><br><span class="line">opacity 属性值小于<span class="number">1</span> </span><br><span class="line">transform/filter 等属性值不为none</span><br><span class="line"></span><br><span class="line">如上，拥有这些属性的元素被称之为拥有层叠上下文属性</span><br></pre></td></tr></table></figure>



<p>第二：需要裁剪的地方会被创建为图层,举个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    div &#123;</span><br><span class="line">        width: <span class="number">200</span>;</span><br><span class="line">        height: <span class="number">200</span>;</span><br><span class="line">        overflow: auto;</span><br><span class="line">        background: gray;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt; 所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下</span></span><br><span class="line"><span class="regexp">        &lt;p&gt; 从上图我们可以看到，document 层上有 A 和 B 层，而 B 层之上又有两个图层。这些图层组</span></span><br><span class="line"><span class="regexp">        &lt;p&gt; 图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上所示，div宽高都是200，超出之后浏览器会自动滚动。出现这种剪裁情况的时候，渲染引擎会为文字部分单独创建一个层，出现滚动的话，滚动条会被提升为单独的层。</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520114909460.png" alt="分层"></p>
<p>如上图文字被单独提升为一层，有滚动的情况下，滚动条也会被单独提升为一层。</p>
<p>到这里，分层完成，分层树构建完成。接下来就是绘制</p>
<h3 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h3><p>渲染引擎会把一个图层的绘制拆分成很多的小的 <strong>绘制指令</strong>，然后再把这些指令按照顺序组成一个待绘制列表。</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520120237554.png" alt="绘制列表"></p>
<p>图层绘制阶段，输出的内容就是这些待绘制的列表。</p>
<h3 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h3><p>绘制列表记录的是绘制顺序，和绘制指令的列表，真正的绘制操作是由渲染引擎中的<strong>合成线程</strong>来完成的。</p>
<p>渲染引擎可以认为是一个进程，从加载页面到计算样式再到布局阶段再到分层都是运行在主线程上的。</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520142913259.png" alt="渲染进程"></p>
<p>如图所示，当图层的绘制列表准备好之后，主线程会把改绘制列表  <strong>提交（commit）</strong>给合成线程.</p>
<h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>合成线程，首先是要注意一个概念 ———— <strong>视口</strong></p>
<h5 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h5><p>视口就是用户能看到的一部分，一个页面可能很大，大到超出当前的屏幕，有时候需要滚动很久才能到底部，用户能看到的就是屏幕那么大的空间。</p>
<p>如果一个页面很大，完全绘制的话是没有意义的，毕竟用户都看不到，性能开销也很大。</p>
<h5 id="图块"><a href="#图块" class="headerlink" title="图块"></a>图块</h5><p>图块是栅格化执行的最小单位。</p>
<p>合成线程会将图层划分为图块，一般这些图块大小都是256x256 或者是 512x512</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520145517614.png" alt="分块"></p>
<p>如图，每一个小块儿就是图块，黑色框就是视口，或者是叫做屏幕，当前需要展示的图块就是 红线画的那些。</p>
<p>视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的，栅格化是指将图块转换为位图。</p>
<p>渲染进程维护了一个栅格化线程池，所有的图块栅格化都是在线程池内执行的，如下：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520151012247.png" alt="渲染进程"></p>
<p>记得一点，栅格化线程将图块转换为位图。一般这个过程会有GPU的参与，用来快速的栅格化，GPU栅格化的位图都保存在GPU中。</p>
<p>GPU是运行在GPU进程中的，这里使用了GPU来快速栅格化，就涉及到跨进程操作了。</p>
<p>操作的流程如下所示：</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520152755253.png" alt="加GPU进程"></p>
<p>这里虽然也叫做栅格化，但是和前边我们说额栅格化不是一回事，比较常见的说法这里的栅格化也可以叫做光栅化。</p>
<h5 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h5><p>位图也叫做点阵图，像素图，光栅图等。</p>
<p>由被称作像素的单个点组成的，这些点可以进行不同的排列组合，比如使用RGB编码，用红绿蓝三原色的光学强度来表示一种颜色</p>
<p>比如 RGB(0,0,0) 表示一个黑色的块儿，不同的RGB拼接在一起就可以形成一幅画。</p>
<p>最常见的，比如 色盲图谱，一个个的点会组成不同的图像或者是数字，这些也可以称之为位图。</p>
<h3 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h3><p>光栅化的最后就生成位图，每一个图层对应一个位图或者是一张图片，最后这些图片会根据层叠的顺序合并为一张图片。</p>
<p>最终生成的图片发送到后缓冲区。</p>
<p>简单的来说，一旦所有的图块都被光栅化了，合成线程就会生成一个绘制图块的命令，该命令会被提交给浏览器进程。</p>
<p>浏览器进程里的有专门的组件来接收这个命令，而后负责将页面内容绘制到内存中。</p>
<h3 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h3><p>页面的显示依靠的是显示器，显示器显示图像的核心是显卡，显示器上的页面（其实是图片）来自于显卡的一个叫做  <strong>前缓冲区</strong>  的地方。</p>
<p>显示器要做的事情很简单，就是每秒钟读取60张图片，并将读取的图片显示在浏览器上。</p>
<h5 id="显卡的职责"><a href="#显卡的职责" class="headerlink" title="显卡的职责"></a>显卡的职责</h5><p>显卡的职责就是不断的合成新的图像，并保存在 <strong>后缓冲区</strong> ，一旦写入完成，系统就会让前后缓冲区对调，保证显示器总是读取最新的图像。一般而言，显卡的更新频率和显示器的刷新频率是一致的，但是，有些时候，在一些复杂的场景中，显卡处理图片会很慢，就会造成卡顿。</p>
<h5 id="帧和帧率"><a href="#帧和帧率" class="headerlink" title="帧和帧率"></a>帧和帧率</h5><p>渲染流水线生成的一张图片，被称之为一帧，每秒钟渲染流水线制造了多少张图片，被称之为帧率。</p>
<p>如果渲染引擎生成某些帧的时间过长了，用户就会觉得卡顿。</p>
<h5 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h5><p>有三种方式来生成一帧图像</p>
<p>第一：重排</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先说说第一种，在首次加载一个网站的时候，这三种方式都会被使用。</span><br><span class="line"></span><br><span class="line">重排很简单，就是修改了元素的几何信息，比如朝DOM里添加一个元素，或者是删除一个元素等，都会触发重排，继而生成一帧图像，这个过程需要 重新构建布局树，而后的渲染阶段都要重新来一遍，这个过程是很耗性能的</span><br></pre></td></tr></table></figure>



<p>第二： 重绘</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重绘不会影响布局阶段，操作效率要比重排要高一些，但是，依旧需要计算绘制信息，触发绘制操作之后的所有操作。 包括 绘制 分块，光栅化，合成，显示等</span><br></pre></td></tr></table></figure>



<p>第三：合成</p>
<p>在合成线程中完成的任务都不会涉及图层内容的改变，一般都是图层的运动操作，比如滚动，动画，旋转等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">相对而言，合成的效率就明显高了很多，合成操作不需要触发布局和绘制操作，而且合成是在合成线程上运行的，不会阻塞主线程，如果合成还采用了GPU的话，效率就更高了。</span><br><span class="line">.box &#123;</span><br><span class="line"> will-change: transform, opacity;</span><br><span class="line"> &#125;</span><br><span class="line">如上，这是告诉渲染进程这个元素要做一些比较秀的操作，transform 或者是 opacity，渲染引擎将该元素单独实现为一层，等变换发生的时候，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，就大大的提升了渲染的效率。</span><br><span class="line"></span><br><span class="line">但是，虽然will-change 好用，但是用的多了也会影响效率的。</span><br></pre></td></tr></table></figure>





<p>最后来一张总结的图</p>
<p><img src="https://raw.githubusercontent.com/wqxc/Picture/main/chrome/image-20210520181235864.png" alt="全部的渲染"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/" data-id="ckoy7a4cy002hipoa8crl2oih" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JS/动画" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/06/JS/%E5%8A%A8%E7%94%BB/" class="article-date">
  <time datetime="2021-04-06T03:24:18.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JS/">JS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/06/JS/%E5%8A%A8%E7%94%BB/">前端的动画</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h2><p>setTimeout 和 setInterval是动画的两个核心api，主要是也使用通过js来操作DOM。</p>
<p>他们的运行机制是，将动画代码添加到浏览器的UI线程队列里等待执行。</p>
<p>如果此时，队列里已经有了很多的任务，就需要等待队列里的任务完成之后才会执行。</p>
<p>每一次队列里的任务数量是不定的，所以，每一次的动画的执行时机也是不定的，或长或短。</p>
<p>举个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function move()&#123;</span><br><span class="line">  var ele &#x3D; document.getElementById(&quot;d&quot;)</span><br><span class="line">  ele.style.left &#x3D; (pareseInt(ele.style.left) + 10)+&#39;px</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(move,500)</span><br></pre></td></tr></table></figure>

<p>每隔500 毫秒就会将id为 d的元素移动10px。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/06/JS/%E5%8A%A8%E7%94%BB/" data-id="ckoy7a4br0006ipoafkftgd8m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB/" rel="tag">动画</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Css/animation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/04/06/Css/animation/" class="article-date">
  <time datetime="2021-04-06T03:23:48.000Z" itemprop="datePublished">2021-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/04/06/Css/animation/">Css/animation</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/06/Css/animation/" data-id="ckoy7a4b60000ipoab6jlhnw1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-React/源码/update" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/30/React/%E6%BA%90%E7%A0%81/update/" class="article-date">
  <time datetime="2021-03-30T06:06:48.000Z" itemprop="datePublished">2021-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React%E6%BA%90%E7%A0%81/">React源码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/30/React/%E6%BA%90%E7%A0%81/update/">源码--update</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>此处承接上文为 [./setState.md]</p>
<p>shouldUpdateReactComponent 函数 会判断当前组件 render 返回的结果 和上一次的 render 之后的 Element 对比，来确定是否需要进一步的对比，或者是简单的卸载和挂载。</p>
<p>shouldUpdateReactComponent 返回 false 表示，无需再进一步对比了，</p>
<p>返回 true 表示需要进一步的对比，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactReconciler.receiveComponent(</span><br><span class="line">        prevComponentInstance,</span><br><span class="line">        nextRenderedElement,</span><br><span class="line">        transaction,</span><br><span class="line">        this._mergeChildContext(context, childContext)</span><br><span class="line">      );</span><br></pre></td></tr></table></figure>

<p>ReactReconciler 是 React 用来处理组件的渲染。React 自身的是不会处理组件的渲染的，而是 React 在合适的时机调用组件的方法来渲染组件，React 就是通过 ReactReconciler 来调用组件的方法的。</p>
<p>核心记得一点：这个时候认为两个组件是一样的，只是内部的内容有些许改动。</p>
<h2 id="ReactReconciler-receiveComponent"><a href="#ReactReconciler-receiveComponent" class="headerlink" title="ReactReconciler.receiveComponent"></a>ReactReconciler.receiveComponent</h2><p>先看看 receiveComponent 方法，它的作用是 Update a component using a new element.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">receiveComponent: function(</span><br><span class="line">   internalInstance, nextElement, transaction, context</span><br><span class="line"> ) &#123;</span><br><span class="line">     ....</span><br><span class="line"></span><br><span class="line">     internalInstance.receiveComponent(nextElement, transaction, context);</span><br><span class="line"></span><br><span class="line">     ....</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>核心是一句话，调用组件实例的 receiveComponent 方法</p>
<h2 id="实例的-receiveComponent-方法"><a href="#实例的-receiveComponent-方法" class="headerlink" title="实例的 receiveComponent 方法"></a>实例的 receiveComponent 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">receiveComponent: function(nextElement, transaction, nextContext) &#123;</span><br><span class="line">  var prevElement &#x3D; this._currentElement;</span><br><span class="line">  var prevContext &#x3D; this._context;</span><br><span class="line"></span><br><span class="line">  this._pendingElement &#x3D; null;</span><br><span class="line"></span><br><span class="line">  this.updateComponent(</span><br><span class="line">    transaction,</span><br><span class="line">    prevElement,</span><br><span class="line">    nextElement,</span><br><span class="line">    prevContext,</span><br><span class="line">    nextContext</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，核心是 调用了 this.updateComponent.<br>这里的 this 就是 组件实例，也就是调用组件实例的 updateComponent 方法。</p>
<h2 id="实例的-updateComponent-方法"><a href="#实例的-updateComponent-方法" class="headerlink" title="实例的 updateComponent 方法"></a>实例的 updateComponent 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">updateComponent: function(</span><br><span class="line">  transaction,</span><br><span class="line">  prevParentElement,</span><br><span class="line">  nextParentElement,</span><br><span class="line">  prevUnmaskedContext,</span><br><span class="line">  nextUnmaskedContext</span><br><span class="line">) &#123;</span><br><span class="line">  var inst &#x3D; this._instance;</span><br><span class="line"></span><br><span class="line">  var nextContext &#x3D; inst.context;</span><br><span class="line">  var nextProps &#x3D; inst.props;</span><br><span class="line"></span><br><span class="line">  if (prevParentElement !&#x3D;&#x3D; nextParentElement) &#123;</span><br><span class="line">    nextContext &#x3D; this._processContext(nextParentElement._context);</span><br><span class="line">    nextProps &#x3D; this._processProps(nextParentElement.props);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (inst.componentWillReceiveProps) &#123;</span><br><span class="line">      inst.componentWillReceiveProps(nextProps, nextContext);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var nextState &#x3D; this._processPendingState(nextProps, nextContext);</span><br><span class="line"></span><br><span class="line">  var shouldUpdate &#x3D;</span><br><span class="line">    this._pendingForceUpdate ||</span><br><span class="line">    !inst.shouldComponentUpdate ||</span><br><span class="line">    inst.shouldComponentUpdate(nextProps, nextState, nextContext);</span><br><span class="line"></span><br><span class="line">  if (shouldUpdate) &#123;</span><br><span class="line">    this._pendingForceUpdate &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; Will set &#96;this.props&#96;, &#96;this.state&#96; and &#96;this.context&#96;.</span><br><span class="line">    this._performComponentUpdate(</span><br><span class="line">      nextParentElement,</span><br><span class="line">      nextProps,</span><br><span class="line">      nextState,</span><br><span class="line">      nextContext,</span><br><span class="line">      transaction,</span><br><span class="line">      nextUnmaskedContext</span><br><span class="line">    );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; If it&#39;s determined that a component should not update, we still want</span><br><span class="line">    &#x2F;&#x2F; to set props and state but we shortcut the rest of the update.</span><br><span class="line">    this._currentElement &#x3D; nextParentElement;</span><br><span class="line">    this._context &#x3D; nextUnmaskedContext;</span><br><span class="line">    inst.props &#x3D; nextProps;</span><br><span class="line">    inst.state &#x3D; nextState;</span><br><span class="line">    inst.context &#x3D; nextContext;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>updateComponent 方法，就是组件的 更新方法，组件只要是更新，都会经历这个方法。</p>
<p>这个方法内主要是做了以下一些事情：</p>
<h3 id="第一步-区分是-props-更新还是-state-更新"><a href="#第一步-区分是-props-更新还是-state-更新" class="headerlink" title="第一步 区分是 props 更新还是 state 更新"></a>第一步 区分是 props 更新还是 state 更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">prevParentElement !&#x3D;&#x3D; nextParentElement</span><br></pre></td></tr></table></figure>

<p>这里主要是区分是 props 更新还是 state 更新<br>prevParentElement 就是 prevElement<br>nextParentElement 就是 nextElement</p>
<p>这里为什么认为 prevParentElement !== nextParentElement 就是 props 更新，而两者相等却是 state 更新。</p>
<p>首先 两者都是 Element，也就是虚拟的 DOM，props 是作为其属性存在于 Element 上，<br>React 的更新主要有两个方法，state 变动或者是 props 变动。</p>
<p>组件的更新行为发生了，但是更新前后两个 Element 完全一致，那只能说明是 state 变化了，state 信息并不会存储在 Element 上，而是存储在组件的实例上。</p>
<p>另外的如果两者不一致，那必然是 props 更新无疑，这就是二选一的事情。</p>
<h5 id="如果是-props-更新"><a href="#如果是-props-更新" class="headerlink" title="如果是 props 更新"></a>如果是 props 更新</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nextContext &#x3D; this._processContext(nextParentElement._context);</span><br><span class="line">nextProps &#x3D; this._processProps(nextParentElement.props);</span><br><span class="line">&lt;!-- _processProps 会在开发环境下校验一下类型，正式环境下不会做任何操作 --&gt;</span><br><span class="line"></span><br><span class="line">if (inst.componentWillReceiveProps) &#123;</span><br><span class="line">    inst.componentWillReceiveProps(nextProps, nextContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要的作用还是调用一下 生命方法 componentWillReceiveProps 方法</p>
<h3 id="第二步，确认是否需要更新"><a href="#第二步，确认是否需要更新" class="headerlink" title="第二步，确认是否需要更新"></a>第二步，确认是否需要更新</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var shouldUpdate &#x3D;</span><br><span class="line">     this._pendingForceUpdate ||</span><br><span class="line">     !inst.shouldComponentUpdate ||</span><br><span class="line">     inst.shouldComponentUpdate(nextProps, nextState, nextContext);</span><br></pre></td></tr></table></figure>

<p>是否更新的条件就几个：<br>1、是否是强制更新 _pendingForceUpdate<br>2、没有定义组件的生命方法 shouldComponentUpdate<br>3、定义了生命方法 shouldComponentUpdate，就看一下生命方法的执行结果</p>
<h3 id="第三步，根据第二步的结果决定如何去做"><a href="#第三步，根据第二步的结果决定如何去做" class="headerlink" title="第三步，根据第二步的结果决定如何去做"></a>第三步，根据第二步的结果决定如何去做</h3><h4 id="返回-false"><a href="#返回-false" class="headerlink" title="返回 false"></a>返回 false</h4><p>表示不需要更新</p>
<p>虽然不需要更新组件，但是，一些信息还是需要更新到组件的实例上去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">this._currentElement &#x3D; nextParentElement;</span><br><span class="line">  this._context &#x3D; nextUnmaskedContext;</span><br><span class="line">  inst.props &#x3D; nextProps;</span><br><span class="line">  inst.state &#x3D; nextState;</span><br><span class="line">  inst.context &#x3D; nextContext;</span><br></pre></td></tr></table></figure>

<h4 id="返回-true"><a href="#返回-true" class="headerlink" title="返回 true"></a>返回 true</h4><p>表示需要更新组件</p>
<p>主要是调用了一个方法来更新组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">this._performComponentUpdate(</span><br><span class="line">  nextParentElement,</span><br><span class="line">  nextProps,</span><br><span class="line">  nextState,</span><br><span class="line">  nextContext,</span><br><span class="line">  transaction,</span><br><span class="line">  nextUnmaskedContext</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="performComponentUpdate"><a href="#performComponentUpdate" class="headerlink" title="_performComponentUpdate"></a>_performComponentUpdate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">_performComponentUpdate: function(</span><br><span class="line">  nextElement,</span><br><span class="line">  nextProps,</span><br><span class="line">  nextState,</span><br><span class="line">  nextContext,</span><br><span class="line">  transaction,</span><br><span class="line">  unmaskedContext</span><br><span class="line">) &#123;</span><br><span class="line">  var inst &#x3D; this._instance;</span><br><span class="line"></span><br><span class="line">  var prevProps &#x3D; inst.props;</span><br><span class="line">  var prevState &#x3D; inst.state;</span><br><span class="line">  var prevContext &#x3D; inst.context;</span><br><span class="line"></span><br><span class="line">  if (inst.componentWillUpdate) &#123;</span><br><span class="line">    inst.componentWillUpdate(nextProps, nextState, nextContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this._currentElement &#x3D; nextElement;</span><br><span class="line">  this._context &#x3D; unmaskedContext;</span><br><span class="line">  inst.props &#x3D; nextProps;</span><br><span class="line">  inst.state &#x3D; nextState;</span><br><span class="line">  inst.context &#x3D; nextContext;</span><br><span class="line"></span><br><span class="line">  this._updateRenderedComponent(transaction, unmaskedContext);</span><br><span class="line"></span><br><span class="line">  if (inst.componentDidUpdate) &#123;</span><br><span class="line">    transaction.getReactMountReady().enqueue(</span><br><span class="line">      inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext),</span><br><span class="line">      inst</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>这个方法主要做了一下几件事：</p>
<p>1、调用组件的生命方法 componentWillUpdate</p>
<p>2、调用方法 _updateRenderedComponent 更新组件</p>
<p>3、调用生命方法 componentDidUpdate 这里 componentDidUpdate 方法的处理是进入队列（这里的 componentDidUpdate 并不是立即执行的，而是要等到子组件都更新完成了才会执行）</p>
<h3 id="看一下-updateRenderedComponent-方法"><a href="#看一下-updateRenderedComponent-方法" class="headerlink" title="看一下 _updateRenderedComponent 方法"></a>看一下 _updateRenderedComponent 方法</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/03/30/React/%E6%BA%90%E7%A0%81/update/" data-id="ckoy7a4e60063ipoah88y932n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81-update/" rel="tag">源码--update</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Other/cookie" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/30/Other/cookie/" class="article-date">
  <time datetime="2021-03-30T03:10:48.000Z" itemprop="datePublished">2021-03-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Other/">Other</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/30/Other/cookie/">Cookie</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie 区分域名，不同域名下的 cookie 是无法相互通信的</p>
<p>但是，cookie 的域是区分端口的。</p>
<p>比如</p>
<p>baidu.com:8000<br>baidu.com:8001</p>
<p>在浏览器的同源策略下，两者是无法通信的，会造成跨域。</p>
<p>但是，两者的 cookie 是互通的。</p>
<p>比如 8000 下，有一个登录，登录之后会返回 cookie，cookie 里带着 ssid，这个 ssid 会被存储在浏览器本地的 domian 为 baidu.com 的空间内。</p>
<p>而后时候 8000 下的应用带着 cookie 就可以进行接口操作</p>
<p>这个时候，8001 下的应用在同一个浏览器下访问了，那么再反过来，访问 8000,就会出现 401.</p>
<p>因为访问 8001 的时候后端依旧会生成 cookie，cookie 里包含 ssid，浏览器接受到这个 ssid 的时候，存储在本地，发现，</p>
<p>baidu.com 这个域名下有一个 ssid 了，于是就替换了它。</p>
<p>这个时候 8000 这个应用再次访问后端接口，带上的 ssid 其实是 访问 8001 的时候生成的。</p>
<p>带着另外的一个应用的 ssi 的去访问，必然会被后端拦截，就造成了 401</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/03/30/Other/cookie/" data-id="ckoy7a4bv000cipoa29ay3hu0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Cookie/" rel="tag">Cookie</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-React/源码/useState" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/24/React/%E6%BA%90%E7%A0%81/useState/" class="article-date">
  <time datetime="2021-03-24T10:12:40.000Z" itemprop="datePublished">2021-03-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React%E6%BA%90%E7%A0%81/">React源码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/24/React/%E6%BA%90%E7%A0%81/useState/">源码--useState</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><p>useState的定义很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export function useState&lt;S&gt;(</span><br><span class="line">  initialState: (() &#x3D;&gt; S) | S,</span><br><span class="line">): [S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt;] &#123;</span><br><span class="line">  const dispatcher &#x3D; resolveDispatcher();</span><br><span class="line">  return dispatcher.useState(initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、resolveDispatcher </p>
<p>就是将  ReactCurrentDispatcher.current 的值返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function resolveDispatcher() &#123;</span><br><span class="line">  const dispatcher &#x3D; ReactCurrentDispatcher.current;</span><br><span class="line">  return dispatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们在使用useState的时候</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useState(0) &#x3D;&#x3D;&#x3D; ReactCurrentDispatcher.current.useState(0)</span><br></pre></td></tr></table></figure>

<p>我们使用useState能够更新组件的原因，因为 ReactCurrentDispatcher.current.useState() 这个方法内做了些操作。</p>
<p>Dispatcher </p>
<p>mountState</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/03/24/React/%E6%BA%90%E7%A0%81/useState/" data-id="ckoy7a4e80068ipoa7oqdci8e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81-useState/" rel="tag">源码--useState</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-React/源码/setState" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/23/React/%E6%BA%90%E7%A0%81/setState/" class="article-date">
  <time datetime="2021-03-23T09:43:52.000Z" itemprop="datePublished">2021-03-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/React%E6%BA%90%E7%A0%81/">React源码</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/23/React/%E6%BA%90%E7%A0%81/setState/">源码--setState</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>setState 的调用是 React 的事件。<br>比如像是下边这样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">handleClick()&#123;</span><br><span class="line">    this.setState(&#123;num:0&#125;)</span><br><span class="line">    this.setState(&#123;num:1&#125;)</span><br><span class="line">    this.setState(&#123;num:2&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;&#123;this.state.num&#125;&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>如此，从用户点击了 button 按钮，到 React 渲染出 button 按钮的文字经历了什么？</p>
<p>1、点击 button 按钮</p>
<p>React 会派生一个合成事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatchEvent: function(topLevelType, nativeEvent) &#123;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心只有上边这一句，作用是开启批处理</p>
<p>2、开启批处理</p>
<p>批处理就批量处理，来一堆处理一下，而不是来一个处理一下，具体的逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function batchedUpdates(callback, a, b, c, d) &#123;</span><br><span class="line">  batchingStrategy.batchedUpdates(callback, a, b, c, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、batchingStrategy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var ReactDefaultBatchingStrategy &#x3D; &#123;</span><br><span class="line">  isBatchingUpdates: false,</span><br><span class="line"></span><br><span class="line">  batchedUpdates: function(callback, a, b, c, d) &#123;</span><br><span class="line">    var alreadyBatchingUpdates &#x3D; ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates &#x3D; true;</span><br><span class="line"></span><br><span class="line">    if (alreadyBatchingUpdates) &#123;</span><br><span class="line">      callback(a, b, c, d);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      transaction.perform(callback, null, a, b, c, d);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：第二步中，将 isBatchingUpdates 字段会被修改为 true，也就是下边这句代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDefaultBatchingStrategy.isBatchingUpdates &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>如上所示，如果当前已经在批处理了，就执行 callback 方法。也就是我们的 handleClick，<br>而，没有批处理，也就是我们在项目初始化后，页面渲染完成了,初次点击了 button 按钮。<br>这个时候:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.perform(callback, null, a, b, c, d);</span><br></pre></td></tr></table></figure>

<p>开启事物处理。</p>
<p>所谓额事物：类似于 axios 的 请求拦截 加 网络请求 加 响应拦截</p>
<p>一次网络请求，先走 了 请求拦截 而后是 真正的 网络请求，再最后 处理一下响应信息。</p>
<p>这里的事物是一样的逻辑。</p>
<p>我们在 callback 的时候，其实就是 handleClick 的是，会先执行 一些前置处理。</p>
<p>而后才是 执行 callback。 callback 执行完毕了就是一些收尾处理。</p>
<p>这里的收尾处理就是 更新组件。</p>
<p>到了这一步，还只是 React 的一些内部的处理信息，接下来是调用 setState 的情况。</p>
<p>4、调用 setState</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.prototype.setState &#x3D; function(partialState, callback) &#123;</span><br><span class="line">    ReactUpdateQueue.enqueueSetState(this, partialState);</span><br><span class="line">    if (callback) &#123;</span><br><span class="line">        ReactUpdateQueue.enqueueCallback(this, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 setState 的时候，其实是调用了 ReactUpdateQueue.enqueueSetState</p>
<p>顾名思义，就是讲 state enqueue</p>
<p>5、enqueueSetState</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">enqueueSetState: function(publicInstance, partialState) &#123;</span><br><span class="line">  var internalInstance &#x3D; getInternalInstanceReadyForUpdate(</span><br><span class="line">    publicInstance,</span><br><span class="line">    &#39;setState&#39;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  if (!internalInstance) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var queue &#x3D;</span><br><span class="line">    internalInstance._pendingStateQueue ||</span><br><span class="line">    (internalInstance._pendingStateQueue &#x3D; []);</span><br><span class="line">  queue.push(partialState);</span><br><span class="line"></span><br><span class="line">  enqueueUpdate(internalInstance);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>拿到当前的组件实例，为实例上的 _pendingStateQueue 添加值。</p>
<p>_pendingStateQueue 是一些等待变更的 state 的队列。</p>
<p>这里，我们 setState 的内容，最终被存储在了 _pendingStateQueue 队列里。</p>
<p>而后 调用了 enqueueUpdate</p>
<p>6、enqueueUpdate</p>
<p>enqueueUpdate 函数的作用很简单，就是调用 ReactUpdates.enqueueUpdate(internalInstance);<br>参数就是当前的组件实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(internalInstance) &#123;</span><br><span class="line">  if (internalInstance !&#x3D;&#x3D; ReactLifeCycle.currentlyMountingInstance) &#123;</span><br><span class="line">    ReactUpdates.enqueueUpdate(internalInstance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7、ReactUpdates.enqueueUpdate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(component) &#123;</span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在第三步的时候 isBatchingUpdates 已经被修改为 true 了。这个时候，enqueueUpdate 函数的主要作用其实就剩下了一项：</p>
<p>dirtyComponents.push(component);</p>
<p>dirtyComponents 是一个数组，数组内存储的就是需要更新的组件。</p>
<p>8、多个 setState</p>
<p>如上 4-7 是调用 setState 的一个过程，就像是例子上我们调用了三次 setState。</p>
<p>那么 4-7 步就会循环执行</p>
<p>最后，handleClick 执行完毕了。</p>
<p>9、尾部处理</p>
<p>回到第三步，React 内部开启了 事物处理机制：transaction.perform</p>
<p>张下边这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var RESET_BATCHED_UPDATES &#x3D; &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: function() &#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates &#x3D; false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var FLUSH_BATCHED_UPDATES &#x3D; &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以认为 initialize 是 axios 里的 请求拦截器里添加的一个拦截函数<br>close 则可以被认为是 响应拦截器里添加了一个拦截。</p>
<p>如上是 批处理的 事物处里，这里是加了两个。</p>
<p>抽离一下：<br>一个事物的机制就如下这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[emptyFunction, emptyFunction, handleClick,</span><br><span class="line">ReactDefaultBatchingStrategy.isBatchingUpdates &#x3D; false,</span><br><span class="line">ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)]</span><br></pre></td></tr></table></figure>

<p>React 会一个个的执行，一个执行完执行下一个。</p>
<p>handleClick 执行完毕了，接着就是 将 isBatchingUpdates 字段修改为 false，表示，批处理结束了。</p>
<p>然后是重点：<strong>ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</strong></p>
<p>10、flushBatchedUpdates</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var flushBatchedUpdates &#x3D; function() &#123;</span><br><span class="line">  while (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    if (dirtyComponents.length) &#123;</span><br><span class="line">      var transaction &#x3D; ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, null, transaction);</span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (asapEnqueued) &#123;</span><br><span class="line">      asapEnqueued &#x3D; false;</span><br><span class="line">      var queue &#x3D; asapCallbackQueue;</span><br><span class="line">      asapCallbackQueue &#x3D; CallbackQueue.getPooled();</span><br><span class="line">      queue.notifyAll();</span><br><span class="line">      CallbackQueue.release(queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>flushBatchedUpdates 函数的作用也很简单 就是 遍历 dirtyComponents，这里又开启了一个事物 ReactUpdatesFlushTransaction。</p>
<p>调用 runBatchedUpdates 来更新组件</p>
<p>11、runBatchedUpdates</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">runBatchedUpdates()&#123;</span><br><span class="line">    ReactReconciler.performUpdateIfNecessary(</span><br><span class="line">      component,</span><br><span class="line">      transaction.reconcileTransaction</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心是调用了 performUpdateIfNecessary 方法</p>
<p>12、performUpdateIfNecessary</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">performUpdateIfNecessary: function(</span><br><span class="line">    internalInstance,</span><br><span class="line">    transaction</span><br><span class="line">) &#123;</span><br><span class="line">  internalInstance.performUpdateIfNecessary(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心 是调用了 internalInstance 组件实例的 performUpdateIfNecessary 方法。<br>这里的关键是确认 组件实例的方法 performUpdateIfNecessary 是什么时候添加上去的，有啥作用。</p>
<p>根据他的名称，我们完全可以猜出来他的作用是 看看组件是否需要更新，需要就更新，不需要就不更新。</p>
<p>组件在实例化的时候就会包含这些方法会被混入组件。</p>
<p>13、performUpdateIfNecessary</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">performUpdateIfNecessary: function(transaction) &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  if (this._pendingStateQueue !&#x3D;&#x3D; null || this._pendingForceUpdate) &#123;</span><br><span class="line">    this.updateComponent(</span><br><span class="line">      transaction,</span><br><span class="line">      this._currentElement,</span><br><span class="line">      this._currentElement,</span><br><span class="line">      this._context,</span><br><span class="line">      this._context</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>留出来核心代码如上所示。在第 5 步的时候，_pendingStateQueue 被赋值了。我们知道</p>
<p>_pendingStateQueue 就是 要更新的 state 的一个队列 — updateComponent</p>
<p>14、updateComponent – 得到最新的 state</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">updateComponent()&#123;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  var nextState &#x3D; this._processPendingState(nextProps, nextContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_processPendingState 方法来对队列里要更新的 state 进行处理</p>
<p>15、_processPendingState</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_processPendingState: function(props, context) &#123;</span><br><span class="line">  var queue &#x3D; this._pendingStateQueue;</span><br><span class="line">  this._pendingStateQueue &#x3D; null;</span><br><span class="line"></span><br><span class="line">  if (!queue) &#123;</span><br><span class="line">    return inst.state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var nextState &#x3D; assign(&#123;&#125;, inst.state);</span><br><span class="line">  for (var i &#x3D;  0; i &lt; queue.length; i++) &#123;</span><br><span class="line">    var partial &#x3D; queue[i];</span><br><span class="line">    assign(</span><br><span class="line">      nextState,</span><br><span class="line">      typeof partial &#x3D;&#x3D;&#x3D; &#39;function&#39; ?</span><br><span class="line">        partial.call(inst, nextState, props, context) :</span><br><span class="line">        partial</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return nextState;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>如上所示，取出 待更新的 state 队列 queue。</p>
<p>取出当前的 state，inst.state</p>
<p>而后 遍历 queue 里的每一项，然后使用 assign 合并进 nextState 里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assign(</span><br><span class="line">       nextState,</span><br><span class="line">       typeof partial &#x3D;&#x3D;&#x3D; &#39;function&#39; ?</span><br><span class="line">         partial.call(inst, nextState, props, context) :</span><br><span class="line">         partial</span><br><span class="line">     );</span><br></pre></td></tr></table></figure>

<p>这里的 assign 是将 queue 里的每一项都合并进 nextState（当前的 state）中，比如<br>当前 state 是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  num:0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>queue 队列里的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    num:1</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    num:2</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    num:3</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>因为他们的 key 值是一样的,后边的会覆盖前边额，合并之后的 state 就直接变成了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    num:3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这也是为啥，我们多次 setState 的时候，中间的 state 变更是被省略掉的。</p>
<p>最后 return nextState</p>
<p>nextState 就是本次组件要更新的时候的 state 的值。</p>
<p>16、updateComponent – 判断是否需要更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var shouldUpdate &#x3D;</span><br><span class="line">      this._pendingForceUpdate ||</span><br><span class="line">      !inst.shouldComponentUpdate ||</span><br><span class="line">      inst.shouldComponentUpdate(nextProps, nextState, nextContext);</span><br></pre></td></tr></table></figure>

<p>如果 _pendingForceUpdate (强制更新) 或者 是组件自己没有 定义 shouldComponentUpdate 方法 或者是 组件定义了方法</p>
<p>并且 inst.shouldComponentUpdate 执行之后返回了 true 就表示应该更新，否则就不更新</p>
<p>16、updateComponent – 不更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this._currentElement &#x3D; nextParentElement;</span><br><span class="line">this._context &#x3D; nextUnmaskedContext;</span><br><span class="line">inst.props &#x3D; nextProps;</span><br><span class="line">inst.state &#x3D; nextState;</span><br><span class="line">inst.context &#x3D; nextContext;</span><br></pre></td></tr></table></figure>

<p>无需更新，赋值完事。</p>
<p>17、updateComponent – 更新<br>核心是调用了 _performComponentUpdate 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if(shouldUpdate)&#123;</span><br><span class="line">  this._pendingForceUpdate &#x3D; false;</span><br><span class="line">      &#x2F;&#x2F; Will set &#96;this.props&#96;, &#96;this.state&#96; and &#96;this.context&#96;.</span><br><span class="line">      this._performComponentUpdate(</span><br><span class="line">        nextParentElement,</span><br><span class="line">        nextProps,</span><br><span class="line">        nextState,</span><br><span class="line">        nextContext,</span><br><span class="line">        transaction,</span><br><span class="line">        nextUnmaskedContext</span><br><span class="line">      );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>17-1、 _performComponentUpdate 如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">_performComponentUpdate()&#123;</span><br><span class="line"></span><br><span class="line">    var inst &#x3D; this._instance;</span><br><span class="line"></span><br><span class="line">    var prevProps &#x3D; inst.props;</span><br><span class="line">    var prevState &#x3D; inst.state;</span><br><span class="line">    var prevContext &#x3D; inst.context;</span><br><span class="line"></span><br><span class="line">    if (inst.componentWillUpdate) &#123;</span><br><span class="line">      inst.componentWillUpdate(nextProps, nextState, nextContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this._currentElement &#x3D; nextElement;</span><br><span class="line">    this._context &#x3D; unmaskedContext;</span><br><span class="line">    inst.props &#x3D; nextProps;</span><br><span class="line">    inst.state &#x3D; nextState;</span><br><span class="line">    inst.context &#x3D; nextContext;</span><br><span class="line"></span><br><span class="line">    this._updateRenderedComponent(transaction, unmaskedContext);</span><br><span class="line"></span><br><span class="line">    if (inst.componentDidUpdate) &#123;</span><br><span class="line">      transaction.getReactMountReady().enqueue(</span><br><span class="line">        inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext),</span><br><span class="line">        inst</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拿到之前的 state，之前的 props，而后看看组件是否有 componentWillUpdate 生命函数。<br>有的话就执行，这时候的时机就是组件在更新之前。</p>
<p>然后呢，就将 新的 state 赋值到 实例上。</p>
<p>而后才是真正的更新组件方法 _updateRenderedComponent</p>
<p>最后 组件更新完了 就执行生命函数 componentDidUpdate</p>
<p>17-2、_updateRenderedComponent<br>这个方法主要做的就是 执行组件的 render 方法，而后相应的更新 DOM</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_updateRenderedComponent()&#123;</span><br><span class="line">    var prevComponentInstance &#x3D; this._renderedComponent;</span><br><span class="line">    var prevRenderedElement &#x3D; prevComponentInstance._currentElement;</span><br><span class="line">    var childContext &#x3D; this._getValidatedChildContext();</span><br><span class="line">    var nextRenderedElement &#x3D; this._renderValidatedComponent(childContext);</span><br><span class="line">    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123;</span><br><span class="line">    ReactReconciler.receiveComponent(</span><br><span class="line">        prevComponentInstance,</span><br><span class="line">        nextRenderedElement,</span><br><span class="line">        transaction,</span><br><span class="line">        this._mergeChildContext(context, childContext)</span><br><span class="line">    );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; These two IDs are actually the same! But nothing should rely on that.</span><br><span class="line">    var thisID &#x3D; this._rootNodeID;</span><br><span class="line">    var prevComponentID &#x3D; prevComponentInstance._rootNodeID;</span><br><span class="line">    ReactReconciler.unmountComponent(prevComponentInstance);</span><br><span class="line"></span><br><span class="line">    this._renderedComponent &#x3D; this._instantiateReactComponent(</span><br><span class="line">        nextRenderedElement,</span><br><span class="line">        this._currentElement.type</span><br><span class="line">    );</span><br><span class="line">    var nextMarkup &#x3D; ReactReconciler.mountComponent(</span><br><span class="line">        this._renderedComponent,</span><br><span class="line">        thisID,</span><br><span class="line">        transaction,</span><br><span class="line">        this._mergeChildContext(context, childContext)</span><br><span class="line">    );</span><br><span class="line">    this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据 shouldUpdateReactComponent 方的返回结果，这个函数会做不同的事情。</p>
<p>shouldUpdateReactComponent 的作用是判断当前的组件是否需要更新。</p>
<p>17-3、_renderValidatedComponent</p>
<p>这个方法的作用是 调用组件的 render 方法的并返回一个结果，这个结果是一个 Element。<br>Element 可以是 对象，字符串 数字 或者干脆是 null</p>
<p>17-3、 shouldUpdateReactComponent</p>
<p>比对 preElement 和 nextElement 来决定组件是否需要更新，这个 shouldUpdateReactComponent 和组件的生命方法 shouldComponentUpdate 不同。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function shouldUpdateReactComponent(prevElement, nextElement) &#123;</span><br><span class="line">  if (prevElement !&#x3D; null &amp;&amp; nextElement !&#x3D; null) &#123;</span><br><span class="line">    var prevType &#x3D; typeof prevElement;</span><br><span class="line">    var nextType &#x3D; typeof nextElement;</span><br><span class="line">    if (prevType &#x3D;&#x3D;&#x3D; &#39;string&#39; || prevType &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">      return (nextType &#x3D;&#x3D;&#x3D; &#39;string&#39; || nextType &#x3D;&#x3D;&#x3D; &#39;number&#39;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (nextType &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp;</span><br><span class="line">          prevElement.type &#x3D;&#x3D;&#x3D; nextElement.type &amp;&amp;</span><br><span class="line">          prevElement.key &#x3D;&#x3D;&#x3D; nextElement.key) &#123;</span><br><span class="line">        var ownersMatch &#x3D; prevElement._owner &#x3D;&#x3D;&#x3D; nextElement._owner;</span><br><span class="line">        var prevName &#x3D; null;</span><br><span class="line">        var nextName &#x3D; null;</span><br><span class="line">        var nextDisplayName &#x3D; null;</span><br><span class="line">        return ownersMatch;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prevElement 和 nextElement 都不为 null 的时候，多做一些操作，否则就直接返回 false，表示 不需要更新</p>
<p>在 17-2 中，我们知道 这个方法返回 false 主要做的事情是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var thisID &#x3D; this._rootNodeID;</span><br><span class="line">var prevComponentID &#x3D; prevComponentInstance._rootNodeID;</span><br><span class="line">ReactReconciler.unmountComponent(prevComponentInstance);</span><br><span class="line"></span><br><span class="line">this._renderedComponent &#x3D; this._instantiateReactComponent(</span><br><span class="line">    nextRenderedElement,</span><br><span class="line">    this._currentElement.type</span><br><span class="line">);</span><br><span class="line">var nextMarkup &#x3D; ReactReconciler.mountComponent(</span><br><span class="line">    this._renderedComponent,</span><br><span class="line">    thisID,</span><br><span class="line">    transaction,</span><br><span class="line">    this._mergeChildContext(context, childContext)</span><br><span class="line">);</span><br><span class="line">this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1、unmountComponent 卸载 之前的组件 prevComponentInstance</p>
<p>2、根据当前的 Element 等参数 实例化组件 _instantiateReactComponent</p>
<p>3、调用组件的 mount 方法生成 markup 也就是 html 文件</p>
<p>4、直接替换 prevComponentID 位置的 html 为 新的 html。</p>
<p>这个时候主要是因为，shouldUpdateReactComponent 返回了 false，表示两个组件完全不一样，React 认为两个组件类型都不一样了，就不考虑遍历对比复用内部组件，而是暴力的直接进行替换。</p>
<p>举个例子 ：<br>prevElement 为 null nextElement 是一个组件实例，这个时候应该无需进一步对比两者的区别，找出变动的部分更新，而是让 nextElement 直接替换 原来位置的 null 就好了。</p>
<p>对应到用户的代码中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    info?&lt;User info&#x3D;&quot;info&quot;&gt;:null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>info 一开始是没有的，这个位置是一个 null，而后，info 有了值，这个地方就是 User 组件。user 组件直接替换了当前位置的 null。</p>
<p>另外的,</p>
<p>如果 prevType 是字符串，或者是数字<br>如果 nextType 也是字符串或者是数字，就返回 true，表示要进步对比。</p>
<p>否则，比如，prevType 是 string 或者是 number，<br>而 string 是一个对象（也就是一个组件），这个时候根本无需进一步对比两者的区别，也是直接替换就行了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (prevType &#x3D;&#x3D;&#x3D; &#39;string&#39; || prevType &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">    return (nextType &#x3D;&#x3D;&#x3D; &#39;string&#39; || nextType &#x3D;&#x3D;&#x3D; &#39;number&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后 看一下 nextType 为 object 的时候</p>
<p>我们知道，React 的组件 render 方法，可以返回 null false，字符串，数字，一个对象（ReactElement）<br>之前的对比逻辑，已经过滤了别的情况，只剩下，prevType 是一个组件。 nextType 也是一个组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (nextType &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp;</span><br><span class="line">          prevElement.type &#x3D;&#x3D;&#x3D; nextElement.type &amp;&amp;</span><br><span class="line">          prevElement.key &#x3D;&#x3D;&#x3D; nextElement.key) &#123;</span><br><span class="line">        var ownersMatch &#x3D; prevElement._owner &#x3D;&#x3D;&#x3D; nextElement._owner;</span><br><span class="line">        var prevName &#x3D; null;</span><br><span class="line">        var nextName &#x3D; null;</span><br><span class="line">        var nextDisplayName &#x3D; null;</span><br><span class="line">        return ownersMatch;</span><br></pre></td></tr></table></figure>

<p>如上所示，对比一下两者的 type 和 key</p>
<p>type： react 的组件 type 指的是 组件的最外层的标签.</p>
<p>如果组件 没有外层标签，而是直接是一个组件：</p>
<p>比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;Count&gt;&lt;&#x2F;Count&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Count 是一个我们自定义的函数组件。</p>
<p>这个时候 type 是 ：函数 ƒ Count()</p>
<p>再比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Count&gt;&lt;&#x2F;Count&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候 type 是 ：div</p>
<p>再比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;Count1&gt;&lt;&#x2F;Count1&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Count1 是一个类组件<br>type 是：class Count1</p>
<p>同样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;Count1&gt;&lt;&#x2F;Count1&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>type 是：div</p>
<p>继续看源码：如果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nextType &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp;</span><br><span class="line">          prevElement.type &#x3D;&#x3D;&#x3D; nextElement.type &amp;&amp;</span><br><span class="line">          prevElement.key &#x3D;&#x3D;&#x3D; nextElement.key</span><br></pre></td></tr></table></figure>

<p>prevElement.type == nextElement.type<br>这句话就是，React 中说的，不要轻易的改动 组件的最外层的元素，因为改动了组件的最外层元素，组件的 type 就变了，React<br>认为他不需要进行 diff，而是直接卸载旧的组件，渲染新的组件。</p>
<p>上边的源码告诉我们，只有在组件 的 type 是一样的，也就是同一个组件，而且如果有 key 的话，key 也必须一致(这里针对的是遍历出来的多个组件)，满足上述的条件之后，React 才会进行 diff 算法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/03/23/React/%E6%BA%90%E7%A0%81/setState/" data-id="ckoy7a4e50061ipoaedaedntp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81-setState/" rel="tag">源码--setState</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Expo/">Expo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JS/">JS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/React/%E6%8A%80%E5%B7%A7/">技巧</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/React%E6%BA%90%E7%A0%81/">React源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/Vue3/">Vue3</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/Vue3/1%E3%80%81https/">1、https</a></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/">状态管理</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/1%E3%80%81%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%83%8C%E6%99%AF/">1、状态管理背景</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/2%E3%80%81MVC%E6%80%9D%E6%83%B3/">2、MVC思想</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/3%E3%80%81Flux%E6%80%9D%E6%83%B3/">3、Flux思想</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/4%E3%80%81Redux/">4、Redux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/4%E3%80%81Redux/Redux%E8%BF%9B%E9%98%B6/">Redux进阶</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/5%E3%80%81React-Redux/">5、React-Redux</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/5%E3%80%81React-Redux/RReact-Redux%E5%86%8D%E6%AC%A1%E8%BF%9B%E9%98%B6/">RReact-Redux再次进阶</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/5%E3%80%81React-Redux/React-Redux%E8%BF%9B%E9%98%B6/">React-Redux进阶</a></li></ul></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%90%86/">浏览器原理</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/API-React-createContext/" rel="tag">API  -- React.createContext</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/API-createRef/" rel="tag">API  -- createRef</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cookie/" rel="tag">Cookie</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Effect-Hook/" rel="tag">Effect-Hook</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Expo%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/" rel="tag">Expo调试工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/FB/" rel="tag">FB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hook%E6%84%9F%E6%82%9F/" rel="tag">Hook感悟</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mixin/" rel="tag">Mixin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RN%E4%B8%8B%E7%9A%84%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/" rel="tag">RN下的阴影效果</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Props-%E5%92%8C-state/" rel="tag">React Props 和 state</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE-Immutability/" rel="tag">React 中的不可变数据 Immutability</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-%E7%BB%84%E4%BB%B6/" rel="tag">React 组件</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React-Redux/" rel="tag">React-Redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/" rel="tag">Redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Render-Props/" rel="tag">Render Props</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/State-Hook/" rel="tag">State-Hook</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/componentWillMount/" rel="tag">componentWillMount</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/componentWillReciveProps/" rel="tag">componentWillReciveProps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/componentdidmount/" rel="tag">componentdidmount</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/constructor/" rel="tag">constructor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/eslint/" rel="tag">eslint</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/getDerivedStateFromProps/" rel="tag">getDerivedStateFromProps</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E6%83%B3/" rel="tag">js的一些思想</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/" rel="tag">js的一些技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shouldComponentUpdate/" rel="tag">shouldComponentUpdate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/useEffect/" rel="tag">useEffect</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/useEffect-%E8%BF%9B%E9%98%B6/" rel="tag">useEffect 进阶</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/useReducer/" rel="tag">useReducer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/" rel="tag">一些技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/" rel="tag">一些概念</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E7%94%BB/" rel="tag">动画</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98/" rel="tag">图片缓存</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9D%91/" rel="tag">坑</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%93/" rel="tag">库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%BB%E7%BB%93/" rel="tag">总结</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A6%82%E6%8B%AC/" rel="tag">概括</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/" rel="tag">模块化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%B8%A7/" rel="tag">渲染与帧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81-setState/" rel="tag">源码--setState</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81-update/" rel="tag">源码--update</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81-useState/" rel="tag">源码--useState</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/" rel="tag">状态管理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%A7%E6%89%BF/" rel="tag">继承</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%83%8C%E6%99%AF/" rel="tag">背景</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D/" rel="tag">路径别名</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B7%AF%E7%94%B1/" rel="tag">路由</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/" rel="tag">高阶组件</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/API-React-createContext/" style="font-size: 10px;">API  -- React.createContext</a> <a href="/tags/API-createRef/" style="font-size: 10px;">API  -- createRef</a> <a href="/tags/Cookie/" style="font-size: 10px;">Cookie</a> <a href="/tags/Effect-Hook/" style="font-size: 10px;">Effect-Hook</a> <a href="/tags/Expo%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">Expo调试工具</a> <a href="/tags/FB/" style="font-size: 10px;">FB</a> <a href="/tags/Hook%E6%84%9F%E6%82%9F/" style="font-size: 10px;">Hook感悟</a> <a href="/tags/Mixin/" style="font-size: 10px;">Mixin</a> <a href="/tags/RN%E4%B8%8B%E7%9A%84%E9%98%B4%E5%BD%B1%E6%95%88%E6%9E%9C/" style="font-size: 10px;">RN下的阴影效果</a> <a href="/tags/React/" style="font-size: 16.67px;">React</a> <a href="/tags/React-Props-%E5%92%8C-state/" style="font-size: 10px;">React Props 和 state</a> <a href="/tags/React-%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE-Immutability/" style="font-size: 10px;">React 中的不可变数据 Immutability</a> <a href="/tags/React-%E7%BB%84%E4%BB%B6/" style="font-size: 10px;">React 组件</a> <a href="/tags/React-Redux/" style="font-size: 13.33px;">React-Redux</a> <a href="/tags/Redux/" style="font-size: 16.67px;">Redux</a> <a href="/tags/Render-Props/" style="font-size: 10px;">Render Props</a> <a href="/tags/State-Hook/" style="font-size: 10px;">State-Hook</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/componentWillMount/" style="font-size: 10px;">componentWillMount</a> <a href="/tags/componentWillReciveProps/" style="font-size: 10px;">componentWillReciveProps</a> <a href="/tags/componentdidmount/" style="font-size: 13.33px;">componentdidmount</a> <a href="/tags/constructor/" style="font-size: 10px;">constructor</a> <a href="/tags/eslint/" style="font-size: 10px;">eslint</a> <a href="/tags/getDerivedStateFromProps/" style="font-size: 10px;">getDerivedStateFromProps</a> <a href="/tags/js%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E6%83%B3/" style="font-size: 10px;">js的一些思想</a> <a href="/tags/js%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">js的一些技巧</a> <a href="/tags/shouldComponentUpdate/" style="font-size: 10px;">shouldComponentUpdate</a> <a href="/tags/useEffect/" style="font-size: 10px;">useEffect</a> <a href="/tags/useEffect-%E8%BF%9B%E9%98%B6/" style="font-size: 10px;">useEffect 进阶</a> <a href="/tags/useReducer/" style="font-size: 10px;">useReducer</a> <a href="/tags/%E4%B8%80%E4%BA%9B%E6%8A%80%E5%B7%A7/" style="font-size: 10px;">一些技巧</a> <a href="/tags/%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5/" style="font-size: 10px;">一些概念</a> <a href="/tags/%E5%8A%A8%E7%94%BB/" style="font-size: 10px;">动画</a> <a href="/tags/%E5%9B%BE%E7%89%87%E7%BC%93%E5%AD%98/" style="font-size: 10px;">图片缓存</a> <a href="/tags/%E5%9D%91/" style="font-size: 10px;">坑</a> <a href="/tags/%E5%BA%93/" style="font-size: 10px;">库</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 10px;">总结</a> <a href="/tags/%E6%A6%82%E6%8B%AC/" style="font-size: 10px;">概括</a> <a href="/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/" style="font-size: 10px;">模块化</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 20px;">浏览器</a> <a href="/tags/%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%B8%A7/" style="font-size: 10px;">渲染与帧</a> <a href="/tags/%E6%BA%90%E7%A0%81-setState/" style="font-size: 10px;">源码--setState</a> <a href="/tags/%E6%BA%90%E7%A0%81-update/" style="font-size: 10px;">源码--update</a> <a href="/tags/%E6%BA%90%E7%A0%81-useState/" style="font-size: 10px;">源码--useState</a> <a href="/tags/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/" style="font-size: 16.67px;">状态管理</a> <a href="/tags/%E7%BB%A7%E6%89%BF/" style="font-size: 13.33px;">继承</a> <a href="/tags/%E8%83%8C%E6%99%AF/" style="font-size: 10px;">背景</a> <a href="/tags/%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D/" style="font-size: 10px;">路径别名</a> <a href="/tags/%E8%B7%AF%E7%94%B1/" style="font-size: 10px;">路由</a> <a href="/tags/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/" style="font-size: 10px;">高阶组件</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%BE%93%E5%85%A5URL%E4%B9%8B%E5%90%8E/">输入URL之后</a>
          </li>
        
          <li>
            <a href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%88%9B%E5%BB%BADOM/">HTML转换为DOM</a>
          </li>
        
          <li>
            <a href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9E%B6%E6%9E%84/">浏览器架构</a>
          </li>
        
          <li>
            <a href="/2021/05/21/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF/">渲染流水线</a>
          </li>
        
          <li>
            <a href="/2021/04/06/JS/%E5%8A%A8%E7%94%BB/">前端的动画</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 WQXC<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>